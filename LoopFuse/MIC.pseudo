flag = false
initialize move_up vector
initialize move_down vector
initialize intervening_code vector

bool dependent(Instruction I, Loop L) {
    if RHS of instruction is updated inside loop (LHS) // write-read
        return true
    if LHS of instruction is updated inside loop (LHS) // write-write
        return true
    if LHS of instruction is read inside loop (RHS) // read-write
        return true
    return false    
}

for each instruction in intervening_code
    check if instruction is dependent on first loop
    if not dependent
        append to move_up
        movable = true
    check if instruction is dependent on second loop
    if not
        append to move_down
        movable = true
    if !movable
        error "cant be fused"
        return false?
figure out dependences between MIC instructions
for each instruction
    check if all dependences got moved in the same spot (take all intersection)
    if intersection is empty
        cant be fused
remove duplicates from move_down that are also found in move_up








=== algorithm in the original paper:
build  a data dependence graph G for intervening code I
map<intervening instruction, Vector<pair<instr it depends on, moved up or down>>>
<list> CanMoveUpSet;
for each inst i in G in topological order:
    if CanMoveUp(Predecessors(i)) and first loop not dependent on i:
        CanMoveUpSet.append(i)
<list> CanMoveDownSet;
for each inst i in G in reverse order:
    if CanMoveDown(Successors(i)) and second loop not dependent on i:
        CanMoveDownSet.append(i)
if CanMoveUpSet + CanMoveDownSet == I:
    return CanFuse
else:
    return !Canfuse
===

Loop 1
MIC 1
MIC 2 (dependent on MIC 1)
MIC 3
Loop 2

1)      for(int i = 0: i < 1; i++) {
            A[i] = 0;
        }
2)      D = A[1]
3)      B[0] = D
4)      for(int i = 0; i < 1; i++) {
            C[i] = B[i]
        }


[Instruction 3 depends on Instruction 2]
1)      for(int i = 0: i < 1; i++) {
            A[i] = 0;
        }
3)      B[0] = D
4)      for(int i = 0; i < 1; i++) {
            C[i] = B[i]
        }
2)      D = A[1]

--------------------------------------------------------------------------------

for each intervening basic block in topological order of CFG
    check if basic block is dependent on first loop (using pseudocode below)
    if not dependent
        append to move up
        movable = true
    check if basic block is dependent on second loop (using pseudocode below)
    if not dependent
        append to move down
        movable = true
    if not movable
        error "can't be fused"
for each basic block
    get the MIC basic blocks that depend it
    for dependences
        if BB and dependence can't be moved in same direction
            error "can't be fused"
move basic blocks
    

bool bbl_dependent_on_loop(bbl, loop)
    for each instruction in basic block
        check if instruction is dependent on the loop
        if dependent
            return false
    return true

                        []
                       /  \
                      /    \
                    []     []
                   /  \
                  /    \
                 []    []

--------------------------------------------------------------------------------


for each basic block in intervening code
    movable = false
    check if basic block is dependent on first loop (BBDep)
    if not dependent
        append to move_up
        movable = true
    check if basic block is dependent on second loop (BBDep)
    if not dependent
        append to move_down
        movable = true
    if not movable
        error can't be moved
if move_up size == num of basic blocks
    move all basic blocks up
    set immediate successor of FC0 to be FC1
else if move_down size == num of basic blocks
    move all basic blocks down
    set immediate successor of FC0 to be FC1
else
    error cant be moved

BBDep:
    for each instruction in basic block
        check if instruction is dependent on loop
        if dependent
            return false
    return true