flag = false
initialize move_up vector
initialize move_down vector
initialize intervening_code vector

bool dependent(Instruction I, Loop L) {
    if RHS of instruction is updated inside loop (LHS) // write-read
        return true
    if LHS of instruction is updated inside loop (LHS) // write-write
        return true
    if LHS of instruction is read inside loop (RHS) // read-write
        return true
    return false    
}

for each instruction in intervening_code
    check if instruction is dependent on first loop
    if not dependent
        append to move_up
        movable = true
    check if instruction is dependent on second loop
    if not
        append to move_down
        movable = true
    if !movable
        error "cant be fused"
        return false?
figure out dependences between MIC instructions
for each instruction
    check if all dependences got moved in the same spot (take all intersection)
    if intersection is empty
        cant be fused
remove duplicates from move_down that are also found in move_up








=== algorithm in the original paper:
build  a data dependence graph G for intervening code I
map<intervening instruction, Vector<pair<instr it depends on, moved up or down>>>
<list> CanMoveUpSet;
for each inst i in G in topological order:
    if CanMoveUp(Predecessors(i)) and first loop not dependent on i:
        CanMoveUpSet.append(i)
<list> CanMoveDownSet;
for each inst i in G in reverse order:
    if CanMoveDown(Successors(i)) and second loop not dependent on i:
        CanMoveDownSet.append(i)
if CanMoveUpSet + CanMoveDownSet == I:
    return CanFuse
else:
    return !Canfuse
===

Loop 1
MIC 1
MIC 2 (dependent on MIC 1)
MIC 3
Loop 2

1)      for(int i = 0: i < 1; i++) {
            A[i] = 0;
        }
2)      D = A[1]
3)      B[0] = D
4)      for(int i = 0; i < 1; i++) {
            C[i] = B[i]
        }


[Instruction 3 depends on Instruction 2]
1)      for(int i = 0: i < 1; i++) {
            A[i] = 0;
        }
3)      B[0] = D
4)      for(int i = 0; i < 1; i++) {
            C[i] = B[i]
        }
2)      D = A[1]

--------------------------------------------------------------------------------

for each intervening basic block in topological order of CFG
    check if basic block is dependent on first loop (using pseudocode below)
    if not dependent
        append to move up
        movable = true
    check if basic block is dependent on second loop (using pseudocode below)
    if not dependent
        append to move down
        movable = true
    if not movable
        error "can't be fused"
for each basic block
    get the MIC basic blocks that depend it
    for dependences
        if BB and dependence can't be moved in same direction
            error "can't be fused"
move basic blocks
    

bool bbl_dependent_on_loop(bbl, loop)
    for each instruction in basic block
        check if instruction is dependent on the loop
        if dependent
            return false
    return true

                        []
                       /  \
                      /    \
                    []     []
                   /  \
                  /    \
                 []    []

--------------------------------------------------------------------------------


for each basic block in intervening code


attempt_mic(){
    queue<*basicBlock> mic_bbs; // queue of blocks in mic we haven't looked at

    while !mic_bbs.empty() {
        // get the next ic bb to check
        current_bb = mic_bb.top()
        mic_bb.pop()
        // check if it's movable
        movable = false
        check if basic block is dependent on first loop (BBDep)
        if not dependent
            append to move_up
            movable = true
        check if basic block is dependent on second loop (BBDep)
        if not dependent
            append to move_down
            movable = true
        if not movable
            error can't be moved
        // add all successors to be checked until we hit the next loop
        for each successor in mic_bbs:
            if successor != beginning of FC1:
                mic_bbs.push(successor)
    }
    
    // all move up or all move down
    // put this in another function call to make it replaceable with another moving up/down routine
    if move_up size == num of basic blocks
        // move all basic blocks up
        // ASSUMPTION: exit block of FC0 contains nothing except intervening code
        // should be something like this:
        // 1. successor of preheader of FC0 should now point to the exit block of the first loop
        // 2. update phi nodes() after every movement
        // 3. IC now becomes the predecessor of FC0
        // 4. predecessor of the preheader of FC1 (should be last black of MIC) should now point to header of first block of FC0
        // 5. successor of FC0 block before exit (we might have to grab this as MIC's pred before moving code) should be entry to FC1

    else if move_down size == num of basic blocks
        move all basic blocks down
        // 1. successor of exit block of fc1 should now point to the exit block of the first loop
        // 2. update phi nodes() after every movement
        // 3. IC now becomes the successor of FC1.exitblock
        // 4. predecessor of the preheader of FC1 should be FC0
    else
        error cant be moved
}




BBDep:
    for each instruction in basic block until the branch
        check if instruction is dependent on loop (InstrDep)
        if dependent
            return false
    return true

InstrDep
    bool dependent(Instruction I, Loop L) {
    if RHS of instruction is updated inside loop (LHS) // write-read
        return true
    if LHS of instruction is updated inside loop (LHS) // write-write
        return true
    if LHS of instruction is read inside loop (RHS) // read-write
        return true
    return false    
}