flag = false
initialize move_up vector
initialize move_down vector
initialize intervening_code vector

bool dependent(Instruction I, Loop L) {
    if RHS of instruction is updated inside loop (LHS) // write-read
        return true
    if LHS of instruction is updated inside loop (LHS) // write-write
        return true
    if LHS of instruction is read inside loop (RHS) // read-write
        return true
    return false    
}

for each instruction in intervening_code
    check if instruction is dependent on first loop
    if not dependent
        append to move_up
        movable = true
    check if instruction is dependent on second loop
    if not
        append to move_down
        movable = true
    if !movable
        error "cant be fused"
figure out dependences between MIC instructions
for each instruction
    check if all dependences got moved in the same spot (take all intersection)
    if intersection is empty
        cant be fused
remove duplicates from move_down that are also found in move_up








=== algorithm in the original paper:
build  a data dependence graph G for intervening code I
map<intervening instruction, Vector<pair<instr it depends on, moved up or down>>>
<list> CanMoveUpSet;
for each inst i in G in topological order:
    if CanMoveUp(Predecessors(i)) and first loop not dependent on i:
        CanMoveUpSet.append(i)
<list> CanMoveDownSet;
for each inst i in G in reverse order:
    if CanMoveDown(Successors(i)) and second loop not dependent on i:
        CanMoveDownSet.append(i)
if CanMoveUpSet + CanMoveDownSet == I:
    return CanFuse
else:
    return !Canfuse
===

Loop 1
MIC 1
MIC 2 (dependent on MIC 1)
MIC 3
Loop 2

1)      for(int i = 0: i < 1; i++) {
            A[i] = 0;
        }
2)      D = A[1]
3)      B[0] = D
4)      for(int i = 0; i < 1; i++) {
            C[i] = B[i]
        }


[Instruction 3 depends on Instruction 2]
1)      for(int i = 0: i < 1; i++) {
            A[i] = 0;
        }
3)      B[0] = D
4)      for(int i = 0; i < 1; i++) {
            C[i] = B[i]
        }
2)      D = A[1]